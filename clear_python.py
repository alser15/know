"""
Данный файл описывает примеры, приведенные в книге 'Чистый Python'
Файл служит исключительно для примера реализации тех или иных функций
"""


def test_assets_example():
    """
    Инструкция assert в Python — пример
    1) assert — это средство отладки, которое проверяет условие, выступающее в качестве внутренней самопроверки вашей
    программы.
    2) Инструкции assert могут быть глобально отключены в настройках
    интерпретатора.
    """
    product = {
        'цена': 100
    }
    discount = 1
    price = product['цена'] * (2.0 - discount)
    assert 0 <= price <= product['цена']
    print(price)


def test_with():
    """
    Пример реализации конструкции with
    Существует общая рекомендация открывать файлы, используя инструкцию with. Это связано с тем,
    что она гарантирует автоматическое закрытие дескрипторов открытых файлов после того, как выполнение
    программы покидает контекст инструкции with

    Режимы open:
    w : Открывает файл для записи и создает файл если он не существует
    w+ : Открывает файл для записи и создает если он не существует. Но если файл уже существует, то перезаписывает его.
    r: Открывает файл только для чтения.
    rb: Открывает файл только для чтения в двоичном формате.
    wb: Открывает файл для записи в двоичном формате
    wb+: Открывает файл для чтения и записи в двоичном формате.
    a: Открывает файл только для добавления в конец его содержимого
    +: В общем, этот символ используется в комбинации с r, w, или a и значит что файл открыт для записи и чтения.
    """
    with open('my_file.txt', 'w+') as f:
        f.write('this is new file')
    try:
        with open('my_file.txt', 'r') as f:
            print(f.read())
    finally:
        import os
        os.remove('my_file.txt')


def test_underlining():
    """
     _var - Префикс, состоящий из символа подчеркивания, подразумевается как
    подсказка, которая должна сообщить другому программисту, что переменная или метод,
    начинающиеся с одинарного символа подчеркивания,предназначаются для внутреннего пользования.

    var_ - Иногда самое подходящее имя переменной уже занято ключевым словом
    языка Python. По этой причине такие имена, как class или def, в Python
    нельзя использовать в качестве имен переменных. В этом случае можно
    в конец имени добавить символ одинарного подчеркивания, чтобы избежать конфликта из-за совпадения имен:
    ">>> def make_object(name, class):"
    SyntaxError: "invalid syntax"

    ">>> def make_object(name, class_):
     ... pass "

     __var - Префикс, состоящий из двойного символа подчеркивания, заставляет
    интерпретатор Python переписывать имя атрибута для того, чтобы в подклассах избежать конфликтов из-за
    совпадения имен.Такое переписывание также называется искажением имени (name
    mangling) — интерпретатор преобразует имя переменной таким образом,
    что становится сложнее создать конфликты, когда позже класс будет
    расширен.

     __var__ -  двойные символы подчеркивания часто называют
    «дандерами» (dunders — это сокращение от англ. double underscores).
    Указывает на специальные методы, такие как __init__, __iter__, __cal__ и т.д., определенные языком Python.
    Следует избегать этой схемы именования для своих собственных
    атрибутов.

    _ - иногда используется в качестве
    имени временных или незначительных переменных («неважных»).
    Кроме того, он представляет результат последнего выражения в сеансе
    интерпретатора REPL Python.
    """
    pass


def test_refactor_str():
    """
    Примеры возможных форматирований строк
    """
    word_one = 'Привет'
    word_two = "Читающий"

    print('%s,' % word_one, "%s" % word_two)
    print('{}, {}'.format(word_one, word_two))
    print(f"{word_one}, {word_two}")


class FUNC:
    """
    Функции
    В Python абсолютно все является объектом, включая функции. Их
    можно присваивать переменным, хранить в структурах данных и передавать или возвращать
    в другие функции и возвращать из них (функции первого класса).

    Функции первого класса позволяют абстрагироваться и раздавать
    линии поведения в ваших программах.

    Функции могут быть вложенными, и они могут захватывать и уносить
    с собой часть состояния родительской функции. Функции, которые это
    делают, называются замыканиями.

    Объекты можно делать вызываемыми. Во многих случаях это позволяет рассматривать их в качестве функций.
    """
    def __init__(self, n):
        """
        Объекты могут вести себя как функции
        Если объект является вызываемым, то это означает, что вы можете использовать с ним синтаксис вызова функций с
        круглыми скобками и даже передавать в него аргументы вызова функции.
        Все это приводится в действие дандер-методом __call__.
        """
        self.n = n

    def __call__(self, x):
        """
        За кадром «вызов» экземпляра объекта в качестве функции сводится
        к исполнению метода __call__ этого объекта.
        Безусловно, не все объекты будут вызываемыми. Вот почему существует
        встроенная функция callable, которая проверяет, является объект вызываемым или нет.
        Пример:
        callable(plus_3)
        True
        callable(yell)
        True
        callable('привет')
        False
        """
        return print(self.n + x)

    @staticmethod
    def bark(text):
        return text

    @classmethod
    def test_func_one(cls, func):
        """
        Функции могут передаваться другим функциям
        Поскольку функции являются объектами, их можно передавать в качестве
        аргументов другим функциям.
        Функции, которые в качестве аргументов могут принимать другие функции, также называются функциями более высокого порядка (higher-order
        functions). Они являются непременным условием функционального стиля
        программирования.
        :param func: объект функци
        :return: текст
        """
        greeting = func
        print(greeting)

    @classmethod
    def test_func_two(cls, text):
        """
        Функции могут быть вложенными
        Всякий раз, когда вы вызываете функцию
        test_func_two, она определяет новую внутреннюю функцию whisper и затем
        после этого немедленно ее вызывает
        """

        def whisper(t):
            return t.upper() + '...'
        return print(whisper(text))


def test():
    """
    Пример реализации test_func_one, test_func_two
    """
    FUNC.test_func_one(FUNC.bark('HI'))
    FUNC.test_func_two('asdf')

def test_():
    """
    Пример вызова обьекта
    """
    plus_3 = FUNC(3)
    plus_3(4)

def test_lambda():
    """
    Ключевое слово lambda в Python предоставляет краткую форму для
    объявления небольших анонимных функций. Лямбда-функции ведут
    себя точно так же, как обычные функции, объявляемые ключевым словом def.
    Они могут использоваться всякий раз, когда требуются объекты-функции

    Лямбда-функции ограничены одним-единственным выражением. Это означает, что в лямбда-функциях не могут
    применяться инструкции или аннотации — и даже инструкция return.

    В лямбда-функциях нельзя использовать обычные инструкции Python,
    и в них всегда содержится неявная инструкция возврата return.
    """
    add = lambda x, y: x + y
    print(add(5, 3)) #8
    print((lambda x, y: x + y)(5, 3)) #8
    # поскольку лямбды могут быть анонимными, перед этим вам даже не
    # нужно назначать им имя
    tuples = [(1, 'd'), (2, 'b'), (4, 'a'), (3, 'c')]
    tuples = sorted(tuples, key=lambda x: x[1]) #В примере мы сортируем список кортежей по второму
    # значению в каждом кортеже. В этом случае лямбда-функция обеспечивает
    # быстрый способ изменить порядок сортировки
    print(tuples) #[(4, 'a'), (2, 'b'), (3, 'c'), (1, 'd')]
    #как и обычные вложенные


def test_lambda_two(n):
    """
    как и обычные вложенные функции, лямбды работают также и как лексические замыкания.
    лексическое замыкание - Это лишь название для  функции, которая помнит значения из объемлющего лексического
    контекста, даже когда поток управления программы больше не находится в этом контексте
    """
    return lambda x: x + n


def test_test():
    """
    Пример функции test_lambda_two
    """
    plus_3 = test_lambda_two(3)
    plus_5 = test_lambda_two(5)
    print(plus_5(4)) #9
    print(plus_3(14)) #17

# Сила декораторов
# Самыми
# важными для понимания декораторов выводами относительно «функций
# первого класса» являются следующие:

# функции являются объектами — их можно присваивать переменным,
# передавать в другие функции и возвращать из других функций;

# функции могут быть определены внутри других функций — и дочерняя функция может захватывать локальное состояние родительской
# функции (лексические замыкания).

# Декораторы позволяют определять конструктивные блоки многократного
# использования, которые могут изменять или расширять поведение других
# функций. И они позволяют это делать без необратимых изменений самой
# обернутой функции. Поведение функции изменяется, только когда оно
# декорировано.

# Декораторы изменяют поведение вызываемого объекта посредством
# обертки-замыкания, в результате чего вам не приходится необратимо
# модифицировать оригинал. Оригинальный вызываемый объект не изменяется необратимо — его поведение меняется,
# только когда он декорирован.
# Это позволяет прикреплять к существующим функциям и классам конструктивные блоки многократного использования,
# в частности функционал журналирования и другое инструментальное оформление.

# Декораторы применяются снизу вверх

def uppercase(func):
    """
    пример декоратора
    декоратор uppercase на лету определяет новую функцию (замыкание) и использует ее в качестве обертки входной функции,
    чтобы изменить ее поведение во время вызова

    Замыкание wrapper имеет доступ к недекорированной входной функции,
    и оно свободно может выполнить дополнительный программный код до
    и после ее вызова

    Декоратор uppercase сам является функцией. И единственный способ повлиять на
    «будущее поведение» входной функции, которую он декорирует, состоит
    в том, чтобы подменить (или обернуть) входную функцию замыканием.
    """
    def wrapper(text):
        original_result = func(text)
        modified_result = original_result.upper()
        return modified_result
    return wrapper


@uppercase
def greeting(text):
    """
    :param text: входная строка
    :return: вернет текст в UPPER
    """
    return text


def test_dec():
    """
    Пример реализации декаратора @uppercase на функции greeting
    """
    print(greeting('qwe'))

# *args и **kwargs позволяют функции принимать необязательные аргументы

def foo(required, *args, **kwargs):
    """
    Если мы вызовем функцию с дополнительными аргументами, то args
    соберет дополнительные позиционные аргументы в кортеж, потому что
    имя параметра имеет префикс *.
    Аналогичным образом, kwargs соберет дополнительные именованные
    аргументы в словарь, потому что имя параметра имеет префикс **.
    Как args, так и kwargs могут быть пустыми, если никакие дополнительные
    аргументы в функцию не переданы.

    Переменная *args собирает дополнительные позиционные аргументы
    в кортеж. Переменная **kwargs собирает дополнительные именованные аргументы в словарь.

    Фактическим синтаксисом является * и **. Названия args и kwargs —
    это просто договоренность (которой следует придерживаться).
    """
    print(required)
    if args:
        print(args)
    if kwargs:
        print(kwargs)

def test_args_kwargs():
    """
    Фактическим синтаксисом является, соответственно, просто
    звездочка (*) или двойная звездочка (**)
    :return: строку, кортеж, словарь
    """
    foo('Что то',1,2,3,4,5, key1='значение', key2=999)